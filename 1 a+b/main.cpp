#include <stdio.h>
/*
异或运算有个别名叫做不进位加法，A^B得到的值就是各位上出去后面进上来的进位后它该有的值，
那么问题就转化成它的哪些位是有进位的。我们知道只有1+1才能产生进位， 也只有1&1的结果才
是1，所以我们可以将两个数做一次与运算来模拟产生进位的位置。但是，进位是要“进”到前一
位，所以我们还需要将A&B的计算结果左移一位，然后再和前面的A&B的结果相加， 但是人家题目
说了不能使用加法，所以致力还是不能直接相加，那怎么办呢？没关系， 继续按照我们这里实现
的这种加法加。只不过两个参数不再是A和B了，而是(A^B)和((A&B)<<1)......

我们应该想到这里面肯定会用到循环，因为加法里面还有加法啊。那什么时候循环结束呢？当加法
中表示进位的数为0时，不用再进行继续下一次加法了。

*/


int main()
{
	int a = 0, b = 0;
	
	int  sum ;
	while (b!=0)
	{
		sum = a ^ b;
		b =  ((a&b) << 1);
		a = sum;

	}
	printf("%d",sum);
	return sum;

}